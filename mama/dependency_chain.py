import os, concurrent.futures
from .build_target import BuildTarget
from .build_dependency import BuildDependency
from .util import save_file_if_contents_changed
from .system import console


def get_cmake_path_list(paths):
    pathlist = '' 
    for path in paths: pathlist += f'\n    "{path}"'
    return pathlist

def get_target_mama_cmake(target):
    cmd = f'# Package {target.name}\n'
    includes = get_cmake_path_list(target.exported_includes)
    libs     = get_cmake_path_list(target.exported_libs)
    cmd += f'set(MAMA_INCLUDES ${{MAMA_INCLUDES}} {includes})\n'
    cmd += f'set(MAMA_LIBS     ${{MAMA_LIBS}}     {libs})\n'
    return cmd

def prepare_mama_cmake_for_build(root_dependency: BuildDependency):
    mama_cmake = ''
    for dependency in root_dependency.children:
        mama_cmake += get_target_mama_cmake(dependency.target)
    # Note: Always save mama.cmake to handle dependency removal
    prolog = '# This file is auto-generated by mama build. Do not modify by hand!\n'
    prolog += 'set(MAMA_INCLUDES "")\n'
    prolog += 'set(MAMA_LIBS     "")\n'
    mama_cmake = prolog + mama_cmake
    save_file_if_contents_changed(f'{root_dependency.src_dir}/mama.cmake', mama_cmake)


def load_child_dependencies(root_dependency: BuildDependency):
    futures = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=8) as e:
        for dep in root_dependency.children:
            futures.append(e.submit(load_dependency_chain, dep))
    changed = False
    for f in futures: changed |= f.result()
    return changed

def load_dependency_chain(root_dependency: BuildDependency):
    changed = root_dependency.load()
    changed |= load_child_dependencies(root_dependency)
    return changed

def build_dependency_chain(root_dependency: BuildDependency):
    for dep in root_dependency.children:
        build_dependency_chain(dep)
    
    prepare_mama_cmake_for_build(root_dependency)
    root_dependency.target.build_target()
